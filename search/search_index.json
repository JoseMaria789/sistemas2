{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"HW1/","title":"RTOS Tasks \u2014 Labs 1, 2 and 3","text":""},{"location":"HW1/#1-summary","title":"1) Summary","text":"<ul> <li>Project Name: LAB 1, 2 and 3</li> <li>Author: Jos\u00e9 Mar\u00eda Meneses Avenda\u00f1o</li> <li>Course / Subject: Embedded Systems II</li> <li>Date: 10/02/2026</li> <li>Brief Description:   These activities introduce the use of FreeRTOS on the ESP32 by creating concurrent tasks, managing priorities and delays, using queues for inter-task communication, and protecting shared resources with mutexes. Through Labs 1, 2, and 3, common issues such as task starvation, queue overflow, and race conditions are analyzed and solved.</li> </ul>"},{"location":"HW1/#lab-1-3-rtos-basics-with-esp-idf-lab","title":"Lab 1-3 \u2014 RTOS Basics with ESP-IDF LAB","text":"<p>The purpose of these labs 1-3 is to analyze changes in our code or new behaviors</p>"},{"location":"HW1/#lab-1","title":"Lab 1","text":""},{"location":"HW1/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li> <p>Implement a multitasking system in FreeRTOS using two concurrent tasks for LED control and serial message output.</p> </li> <li> <p>Validate the effect of task priorities and task blocking on the behavior of the FreeRTOS scheduler, as well as the prevention of starvation through the use of vTaskDelay.</p> </li> <li> <p>Document the source code, the results of the conducted experiments, and the observations obtained regarding concurrent task execution.</p> </li> </ul>"},{"location":"HW1/#2-exercises","title":"2) Exercises","text":"<ol> <li>Priority experiment: change <code>hello_task</code> priority from <code>5</code> to <code>2</code>.</li> <li>Does behavior change? Why might it (or might it not)?</li> <li>Starvation demo:<code>temporarily remove vTaskDelay(...)</code>from <code>hello_task</code>.</li> <li>What happens to blinking?</li> <li>Put the delay back and explain in one sentence why blocking helps.</li> </ol>"},{"location":"HW1/#3-materials-setup","title":"3) Materials &amp; Setup","text":"<p>BOM (bill of materials)</p> # Item Qty Link/Source Cost (MXN) Notes 1 ESP32 1 amazon $365 Nothing 2 Led 1 Electronic store $3 Nothing <p>Tools / Software </p> <ul> <li>OS/Env: ESP-IDF with FreeRTOS on ESP32 (Windows) </li> <li>Editors: VS Code with ESP-IDF extension, C/C++, Debug/Flash: ESP-IDF </li> </ul> <p>Wiring / Safety </p> <ul> <li> <p>Board power: USB 5 V from host PC</p> </li> <li> <p>LED: Onboard LED (GPIO 2)</p> </li> <li> <p>Safety notes: Verify correct GPIO pin for the board; avoid short circuits during wiring </p> </li> </ul>"},{"location":"HW1/#4-procedure-what-you-did","title":"4) Procedure (what you did)","text":"<ul> <li>Step 1: Create a new ESP-IDF project and configure the target ESP32 board </li> <li>Step 2: Implement two FreeRTOS tasks: one for LED blinking and one for serial logging </li> <li>Step 3: Build, flash, and monitor the application using ESP-IDF tools </li> <li>Step 4: Modify task priorities and observe scheduler behavior </li> <li>Step 5: Remove and restore vTaskDelay in one task to demonstrate * starvation and recovery </li> <li>Step 6: Verify correct LED blinking and periodic serial output </li> </ul>"},{"location":"HW1/#5-data-tests-evidence","title":"5) Data, Tests &amp; Evidence","text":"<p>Test plan: </p> <ul> <li>Inputs: Task priorities, presence or absence of vTaskDelay </li> <li>Expected: Stable LED blinking and periodic log output when tasks are properly blocked </li> </ul> <p>Tables/observations: |Case|Configuration|LED Behavior|Serial Output|Pass|  |-------------|-----------|-------------|------------|-----------|   |A|Both tasks priority 5, delays enabled|Normal blinking|Periodic|    |B|hello_task priority 2, delays enabled|Normal blinking| Periodic|    |C|without vTaskDelay|Yes / unstable blinking|Continuous output|  |D|vTaskDelay restored|Normal blinking|Periodic|   </p>"},{"location":"HW1/#6-analysis","title":"6) Analysis","text":"<p>Observed behavior matches the expected FreeRTOS scheduling model. When tasks use vTaskDelay, they enter the Blocked state, allowing the scheduler to execute other ready tasks regardless of priority differences Removing vTaskDelay causes one task to continuously occupy the CPU, leading to starvation of the LED task. This behavior illustrates the importance of cooperative blocking in real-time multitasking systems. Proposed fixes: Ensure all tasks include appropriate blocking calls (vTaskDelay, queues, or synchronization primitives). </p>"},{"location":"HW1/#7-code","title":"7) Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"HW1/#8-files-media","title":"8) Files &amp; Media","text":"<p>connection diagram: </p> <p>Video:</p>"},{"location":"HW1/#lab-2","title":"Lab 2","text":""},{"location":"HW1/#1-activity-goals_1","title":"1) Activity Goals","text":"<ul> <li> <p>Implement inter-task communication in FreeRTOS using queues with a producer\u2013consumer model.</p> </li> <li> <p>Validate correct data transfer, task synchronization, and blocking behavior using xQueueSend and xQueueReceive.</p> </li> <li> <p>Document the source code, experimental results, and observations related to queue-based task communication.</p> </li> </ul>"},{"location":"HW1/#2-exercises_1","title":"2) Exercises","text":"<ol> <li>Make the producer faster: change producer delay <code>200ms \u2192 20ms</code>.</li> <li>When do you see \u201cQueue full\u201d?</li> <li>Increase the queue length <code>5 \u2192 20</code>. </li> <li>What changes?</li> <li>Make the consumer \u201cslow\u201d: after a successful receive, add: <pre><code>vTaskDelay(pdMS_TO_TICKS(300));\n</code></pre></li> <li>What pattern is happening now (buffering / backlog)?</li> </ol>"},{"location":"HW1/#3-materials-setup_1","title":"3) Materials &amp; Setup","text":"<p>BOM (bill of materials)</p> # Item Qty Link/Source Cost (MXN) Notes 1 ESP32 1 amazon $365 Nothing <p>Tools / Software </p> <ul> <li> <p>OS/Env: ESP-IDF with FreeRTOS on ESP32 (Windows) </p> </li> <li> <p>Editors: VS Code with ESP-IDF extension, C/C++</p> </li> <li> <p>Debug/Flash: ESP-IDF </p> </li> </ul> <p>Wiring / Safety </p> <ul> <li> <p>Board power: USB 5 V from host PC </p> </li> <li> <p>LED: Onboard LED (GPIO 2) </p> </li> <li> <p>Safety notes: Verify correct GPIO pin for the board; avoid short circuits during wiring </p> </li> </ul>"},{"location":"HW1/#4-procedure-what-you-did_1","title":"4) Procedure (what you did)","text":"<ul> <li>Step 1: Create a new ESP-IDF project and configure the target ESP32 board </li> <li>Step 2: Create a FreeRTOS queue to store integer values </li> <li>Step 3: Implement a producer task that sends data to the queue using xQueueSend </li> <li>Step 4: Implement a consumer task that receives data from the queue using xQueueReceive </li> <li>Step 5: Build, flash, and monitor the application using ESP-IDF tools </li> <li>Step 6: Observe task behavior when the queue is full or empty and verify proper blocking </li> </ul>"},{"location":"HW1/#5-data-tests-evidence_1","title":"5) Data, Tests &amp; Evidence","text":"<p>Test plan </p> <ul> <li> <p>Inputs: Queue length, send/receive delays, blocking timeouts </p> </li> <li> <p>Expected: Reliable data transfer with tasks blocking when the queue is full or empty </p> </li> </ul> <p>Results: </p> <p>Tables/observations Case | Configuration | Queue Behavior | Task State | Pass? A | Queue length 5, normal delays | Stable FIFO operation | Blocked/Ready |  B | Producer faster than consumer | Queue fills correctly | Producer blocked |  C | Consumer faster than producer | Queue empties correctly | Consumer blocked |  D | Balanced producer/consumer | Continuous data flow | Normal operation |   </p>"},{"location":"HW1/#6-analysis_1","title":"6) Analysis","text":"<p>Observed behavior matches the expected FreeRTOS queue model. When xQueueSend or xQueueReceive is called with a blocking timeout, tasks enter the Blocked state until the queue condition is satisfied. This prevents CPU starvation and allows efficient synchronization between producer and consumer tasks. The experiment demonstrates how FreeRTOS queues provide both data transfer and task synchronization in real-time systems. Proposed fixes: Use appropriate queue sizes and blocking times to ensure reliable and efficient inter-task communication. </p>"},{"location":"HW1/#7-code_1","title":"7) Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"HW1/#8-files-media_1","title":"8) Files &amp; Media","text":"<p>Video:</p>"},{"location":"HW1/#lab-3","title":"Lab 3","text":""},{"location":"HW1/#1-activity-goals_2","title":"1) Activity Goals","text":"<ul> <li>Implement task synchronization in FreeRTOS using binary semaphores and mutexes.</li> <li>Validate mutual exclusion and proper synchronization between concurrent tasks accessing shared resources.</li> <li>Document the source code, experimental results, and observations related to synchronization mechanisms in real-time systems.</li> </ul>"},{"location":"HW1/#2-exercises_2","title":"2) Exercises","text":"<ol> <li>Remove the mutex again. Do you ever see weird behavior?</li> <li>Change priorities: TaskA priority <code>6</code>, TaskB priority <code>4</code>.</li> <li>What do you expect and why?</li> <li>In one sentence: what does a mutex \u201cguarantee\u201d?</li> </ol>"},{"location":"HW1/#3-materials-setup_2","title":"3) Materials &amp; Setup","text":"<p>BOM (bill of materials)</p> # Item Qty Link/Source Cost (MXN) Notes 1 ESP32 1 amazon $365 Nothing <p>Tools / Software OS/Env: ESP-IDF with FreeRTOS on ESP32 (Windows) Editors: VS Code with ESP-IDF extension, C/C++ _Debug/Flash: ESP-IDF monitor and flashing tools </p> <p>Wiring / Safety Board power: USB 5 V from host PC External hardware: None (serial monitor only) Safety notes: Ensure stable USB connection during flashing and monitoring </p>"},{"location":"HW1/#4-procedure-what-you-did_2","title":"4) Procedure (what you did)","text":"<p>Step 1: Create a new ESP-IDF project and configure the target ESP32 board Step 2: Define a shared resource (e.g., a global counter or shared print section) Step 3: Create a mutex using xSemaphoreCreateMutex to protect the shared resource Step 4: Implement two or more tasks that attempt to access the shared resource concurrently Step 5: Use xSemaphoreTake and xSemaphoreGive to enforce mutual exclusion Step 6: Build, flash, and monitor the application using ESP-IDF tools Step 7: Temporarily remove the mutex protection to observe race_ conditions and inconsistent behavior_ Step 8: Restore synchronization and verify stable and predictable execution </p>"},{"location":"HW1/#5-data-tests-evidence_2","title":"5) Data, Tests &amp; Evidence","text":"<p>Test plan Inputs: Presence or absence of mutex protection, task priorities Expected: Consistent shared resource access when mutex is used; race conditions when not protected </p> <p>Tables/observations Case | Configuration | Shared Resource Behavior | System Stability | Pass? A | Mutex enabled | Ordered and consistent access | Stable |  B | Mutex removed | Race condition observed | Inconsistent output |  C | Different task priorities with mutex | Correct mutual exclusion | Stable |  D | Binary semaphore for signaling | Proper task synchronization | Stable |   </p>"},{"location":"HW1/#6-analysis_2","title":"6) Analysis","text":"<p>Observed behavior confirms the importance of synchronization mechanisms in multitasking systems. When a mutex is used, only one task at a time can access the shared resource, preventing race conditions and ensuring data integrity. Without synchronization, concurrent access leads to unpredictable behavior due to simultaneous modifications of shared data. Binary semaphores allow task signaling, while mutexes provide mutual exclusion with priority inheritance support. The experiment demonstrates how proper synchronization is essential for reliability and determinism in real-time embedded systems. Proposed fixes: Always protect shared resources with mutexes and use semaphores for task signaling to prevent race conditions and ensure system stability.</p>"},{"location":"HW1/#7-code_2","title":"7) Code","text":"<p>Part A \u2014 Race demo (no mutex): <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> Part B \u2014 Fix with a mutex: <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre></p>"},{"location":"HW1/#8-files-media_2","title":"8) Files &amp; Media","text":"<p>Video:</p>"},{"location":"miniCHALLENGES/","title":"Mini Challegends","text":"<p>Purpose of the session:</p> <p>Develop and test an advanced FreeRTOS system using mutexes, queues with structs, heartbeat supervision, and centralized error logging.</p>"},{"location":"miniCHALLENGES/#lab-1","title":"Lab 1","text":""},{"location":"miniCHALLENGES/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li> <p>Extend the FreeRTOS multitasking system by integrating heartbeat monitoring, structured queue communication, mutex-protected shared resources, and centralized error handling.</p> </li> <li> <p>Validate synchronization mechanisms (mutex), structured message passing (queues with structs), and system robustness under simulated error conditions.</p> </li> <li> <p>Document the system architecture, task interactions, error management strategy, and observed runtime behavior.</p> </li> </ul>"},{"location":"miniCHALLENGES/#2exercises","title":"2)Exercises","text":"<p>1) Heartbeat + work task 2) Add a third task that prints \u201calive\u201d every 2 seconds. 3) Queue with struct 4) Send a struct: <code>{int id; int value;}</code> 5) _Mutex around a shared peripheral 6) Make two tasks write to the same log message format (simulate \u201cshared UART resource\u201d) and guard it with a mutex. 7) Log any error (message of any error)</p>"},{"location":"miniCHALLENGES/#3-materials-setup","title":"3) Materials &amp; Setup","text":"<p>BOM (bill of materials)</p> # Item Qty Link/Source Cost (MXN) Notes 1 ESP32 1 amazon $365 Nothing 2 Led 1 Electronic store $3 Nothing 3 Push button 2 Electronic store $2 Nothing <p>Tools / Software </p> <ul> <li> <p>OS/Env: ESP-IDF with FreeRTOS on ESP32 (Windows) </p> </li> <li> <p>Editors: VS Code with ESP-IDF extension, C/C++ </p> </li> <li> <p>Debug/Flash: ESP-IDF monitor and flashing tools </p> </li> </ul> <p>Wiring / Safety </p> <ul> <li> <p>Board power: USB 5 V from host PC </p> </li> <li> <p>Peripherals: LED (GPIO 4), Button 1 (GPIO 18), Button 2 (GPIO 19) </p> </li> <li> <p>Safety notes: Verify correct GPIO mapping, enable pull-ups for buttons, avoid short circuits </p> </li> </ul>"},{"location":"miniCHALLENGES/#4-procedure-what-you-did","title":"4) Procedure (what you did)","text":"<ul> <li>Step 1: Created shared system resources including a mutex (counter_mutex), a message queue (msg_queue), and an error queue (error_queue). </li> <li>Step 2: Implemented two increment tasks that safely update a shared counter using a mutex to ensure mutual exclusion. </li> <li>Step 3: Added a heartbeat task that toggles an LED and periodically reports system status, generating a fatal error after a defined number of cycles. </li> <li>Step 4: Implemented a producer task that sends structured messages <code>{int id; int value;}</code> to a queue. </li> <li>Step 5: Implemented a consumer task that receives and logs structured messages from the queue. </li> <li>Step 6: Added two button-monitoring tasks that detect simultaneous button presses and generate error events. </li> <li>Step 7: Implemented a centralized error logger task that receives error codes from an error queue and logs them. </li> <li>Step 8: Built, flashed, and monitored the application to validate correct synchronization, communication, and error handling behavior.</li> </ul>"},{"location":"miniCHALLENGES/#5-data-tests-evidence","title":"5) Data, Tests &amp; Evidence","text":"<p>Test plan: </p> <ul> <li>Inputs: Button presses, heartbeat cycles, producer message rate, shared counter access </li> </ul> <p>Expected: </p> <ul> <li>Safe shared counter increments with no race conditions </li> <li>Proper FIFO message transfer using struct-based queue </li> <li>Error events logged when triggered </li> <li>Centralized error reporting via error_logger_task </li> </ul> <p>Tables/observations Case | Configuration | Observed Behavior | System Stability | Pass? A | Mutex enabled for counter | Consistent counter increments | Stable | B | Struct queue active | Correct id/value received | Stable | C | Both buttons pressed | Error code generated and logged | Stable | D | Heartbeat fatal cycle triggered | Fatal error logged and recovered | Stable | E | Producer periodic error log | Error message printed | Stable |  </p>"},{"location":"miniCHALLENGES/#6-analysis","title":"6) Analysis","text":"<p>The extended system demonstrates advanced multitasking coordination in FreeRTOS. The mutex successfully protects the shared_counter variable, preventing race conditions between increment_task instances. The struct-based queue ensures reliable FIFO communication between producer_task and consumer_task, demonstrating safe structured data transfer. The heartbeat mechanism introduces supervised periodic system activity and simulated fatal conditions, validating system recovery logic. Button monitoring tasks generate asynchronous events, which are safely handled through an error queue and centralized error_logger_task.</p> <p>This architecture illustrates modular real-time system design using: </p> <ul> <li>Mutual exclusion (mutex) </li> <li>Structured inter-task communication (queues with structs) </li> <li>Event-driven error handling </li> <li>Priority-based scheduling </li> </ul> <p>Proposed improvements: </p> <ul> <li>Add priority inheritance testing, implement ISR-based button handling, or integrate watchdog supervision for enhanced fault tolerance. </li> </ul>"},{"location":"miniCHALLENGES/#7-code","title":"7) Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n#include \"driver/gpio.h\"\n\n#define LED   GPIO_NUM_4\n#define BTN1  GPIO_NUM_18\n#define BTN2  GPIO_NUM_19\n\nstatic const char *TAG  = \"LAB3\";\nstatic const char *QTAG = \"QUEUE\";\n\ntypedef struct {\n    int id;\n    int value;\n} message_t;\n\ntypedef enum {\n    ERR_QUEUE_FULL = 1,\n    ERR_BUTTON_STUCK,\n    ERR_BOTH_BUTTONS_PRESSED,\n    ERR_FATAL_HEARTBEAT\n} error_t;\n\nstatic volatile int shared_counter = 0;\nstatic volatile int btn1_pressed = 0;\nstatic volatile int btn2_pressed = 0;\n\nstatic SemaphoreHandle_t counter_mutex;\nstatic QueueHandle_t msg_queue;\nstatic QueueHandle_t error_queue;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n        shared_counter++;\n        if ((shared_counter % 501) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n        xSemaphoreGive(counter_mutex);\n        vTaskDelay(pdMS_TO_TICKS(10));\n    }\n}\n\nstatic void heartbeat_task(void *pvParameters)\n{\n    gpio_reset_pin(LED);\n    gpio_set_direction(LED, GPIO_MODE_OUTPUT);\n\n    int alive_cycles = 0;\n\n    while (1) {\n\n        if (alive_cycles &lt; 8) {\n            gpio_set_level(LED, 1);\n            ESP_LOGI(\"HEARTBEAT\", \"alive\");\n            vTaskDelay(pdMS_TO_TICKS(2000));\n\n            gpio_set_level(LED, 0);\n            vTaskDelay(pdMS_TO_TICKS(2000));\n\n            alive_cycles++;\n        }\n\n        else {\n            gpio_set_level(LED, 0);\n            ESP_LOGE(\"HEARTBEAT\", \"ERROR FATAL\");\n\n            error_t err = ERR_FATAL_HEARTBEAT;\n            xQueueSend(error_queue, &amp;err, 0);\n\n            vTaskDelay(pdMS_TO_TICKS(4000));\n            alive_cycles = 0;\n        }\n    }\n}\n\nstatic void producer_task(void *pvParameters)\n{\n    message_t msg;\n    int value = 0;\n    int error_timer = 0;\n\n    while (1) {\n        msg.id = 1;\n        msg.value = value++;\n        xQueueSend(msg_queue, &amp;msg, portMAX_DELAY);\n\n        error_timer++;\n        if (error_timer &gt;= 5) {\n            ESP_LOGE(\"PRODUCER\", \"ERROR ENCONTRADO\");\n            error_timer = 0;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    message_t msg;\n    TickType_t last_error = xTaskGetTickCount();\n\n    while (1) {\n        if (xQueueReceive(msg_queue, &amp;msg, portMAX_DELAY)) {\n            ESP_LOGI(QTAG, \"Received id=%d value=%d\", msg.id, msg.value);\n        }\n\n        if ((xTaskGetTickCount() - last_error) &gt;= pdMS_TO_TICKS(5000)) {\n            ESP_LOGE(\"CONSUMER\", \"ERROR ENCONTRADO\");\n            last_error = xTaskGetTickCount();\n        }\n    }\n}\n\nstatic void button1_task(void *pvParameters)\n{\n    int last_state = 1;\n    while (1) {\n        int state = gpio_get_level(BTN1);\n        if (state == 0 &amp;&amp; last_state == 1) {\n            ESP_LOGI(\"BTN1\", \"Button 1 pressed\");\n            btn1_pressed = 1;\n            if (btn2_pressed) {\n                error_t err = ERR_BOTH_BUTTONS_PRESSED;\n                xQueueSend(error_queue, &amp;err, 0);\n            }\n        }\n        if (state == 1) btn1_pressed = 0;\n        last_state = state;\n        vTaskDelay(pdMS_TO_TICKS(50));\n    }\n}\n\nstatic void button2_task(void *pvParameters)\n{\n    int last_state = 1;\n    while (1) {\n        int state = gpio_get_level(BTN2);\n        if (state == 0 &amp;&amp; last_state == 1) {\n            ESP_LOGI(\"BTN2\", \"Button 2 pressed\");\n            btn2_pressed = 1;\n            if (btn1_pressed) {\n                error_t err = ERR_BOTH_BUTTONS_PRESSED;\n                xQueueSend(error_queue, &amp;err, 0);\n            }\n        }\n        if (state == 1) btn2_pressed = 0;\n        last_state = state;\n        vTaskDelay(pdMS_TO_TICKS(50));\n    }\n}\n\nstatic void error_logger_task(void *pvParameters)\n{\n    error_t err;\n    while (1) {\n        if (xQueueReceive(error_queue, &amp;err, portMAX_DELAY)) {\n            ESP_LOGE(\"ERROR_LOGGER\", \"Error recibido: %d\", err);\n        }\n    }\n}\n\nstatic void init_buttons(void)\n{\n    gpio_config_t io_conf = {\n        .pin_bit_mask = (1ULL &lt;&lt; BTN1) | (1ULL &lt;&lt; BTN2),\n        .mode = GPIO_MODE_INPUT,\n        .pull_up_en = GPIO_PULLUP_ENABLE,\n        .pull_down_en = GPIO_PULLDOWN_DISABLE\n    };\n    gpio_config(&amp;io_conf);\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3 (Extended Error Logic)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    msg_queue   = xQueueCreate(10, sizeof(message_t));\n    error_queue = xQueueCreate(5, sizeof(error_t));\n\n    init_buttons();\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n\n    xTaskCreate(heartbeat_task, \"heartbeat\", 2048, NULL, 3, NULL);\n\n    xTaskCreate(producer_task, \"producer\", 2048, NULL, 4, NULL);\n    xTaskCreate(consumer_task, \"consumer\", 2048, NULL, 4, NULL);\n\n    xTaskCreate(button1_task, \"button1\", 2048, NULL, 4, NULL);\n    xTaskCreate(button2_task, \"button2\", 2048, NULL, 4, NULL);\n\n    xTaskCreate(error_logger_task, \"error_logger\", 2048, NULL, 6, NULL);\n}\n</code></pre>"},{"location":"miniCHALLENGES/#8-files-media","title":"8) Files &amp; Media","text":"<p>connection diagram: </p> <p>Video: </p>"}]}